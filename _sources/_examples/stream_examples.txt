
Getting Started
***************
Import the energiscore library and other dependencies.

.. code:: python

    import energistream as es # Imports the Energiscore Library
    import pandas as pd # Imports the Pandas Library for Dataframe handling
    import datetime as dt # Imports the datetime Library for timeseries handling
    import numpy as np # Imports the Numpy Library for series handling
    import scipy as sp # Imports scipy package
    
    import seaborn as sns # Imports seaborn for graph generation
    import matplotlib # Imports matplotlib for math functionality
.. code:: python

    %load_ext autoreload 
    %autoreload 2 
    # Running autoreload will reload any updated modules before running a cell. 
    %pylab inline 
    %matplotlib inline 
    #pylab inline and matplotlib inline will cause charts to be displayed within ipython notebook.

.. parsed-literal::

    Populating the interactive namespace from numpy and matplotlib


Client Instantiation and Authentication
***************************************
``EnergiStreamClient`` takes a valid username and password and establishes a unique session with temporary credentials. 

Note : The following cell extracts the user credentials from an external text file to avoid displaying sensitive client information. 

.. code:: python

    with open('../credentials.txt') as f:
        credentials = [x.strip().split(':') for x in f.readlines()]
        
    USER = credentials[0][0]
    PASS = credentials[0][1]
.. code:: python

    
    stream = es.EnergiStreamClient(USER, PASS, include_sensors=True) 

External Data
*************
``get_weather`` returns a dataframe of hourly temperature and relative humidity data for the instantiated client's associated physical location. Note : This data is collected from third party sources. Weather ID is an energistream unique key and not associated to any third party ID schema.

.. code:: python

    stream.get_weather(weather_id = 102, start = '12/29/2014', end = '1/29/2015').head()



.. raw:: html

    <div style="max-height:1000px;max-width:1500px;overflow:auto;">
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>c</th>
          <th>f</th>
          <th>h</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>2014-12-29 00:00:00+00:00</th>
          <td> 15.6</td>
          <td> 60</td>
          <td> 42</td>
        </tr>
        <tr>
          <th>2014-12-29 01:00:00+00:00</th>
          <td> 15.0</td>
          <td> 59</td>
          <td> 48</td>
        </tr>
        <tr>
          <th>2014-12-29 02:00:00+00:00</th>
          <td> 13.3</td>
          <td> 56</td>
          <td> 55</td>
        </tr>
        <tr>
          <th>2014-12-29 03:00:00+00:00</th>
          <td> 13.3</td>
          <td> 56</td>
          <td> 53</td>
        </tr>
        <tr>
          <th>2014-12-29 04:00:00+00:00</th>
          <td> 12.2</td>
          <td> 54</td>
          <td> 57</td>
        </tr>
      </tbody>
    </table>
    </div>



Energistream Data and Metadata
******************************
``get_energy`` accepts a sensor ID and returns a dataframe relating active and reactive energy, current and voltage RMS, and total Energy.

.. code:: python

    stream.get_energy(3505, start = '12/29/2014', end = '1/29/2015', tz = 'local').head()



.. raw:: html

    <div style="max-height:1000px;max-width:1500px;overflow:auto;">
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>activeEnergy</th>
          <th>currentRMS</th>
          <th>powerFactor</th>
          <th>reactiveEnergy</th>
          <th>sensorId</th>
          <th>totalEnergy</th>
          <th>voltageRMS</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>2014-12-29 00:01:00-08:00</th>
          <td> 43566.626</td>
          <td> 27.44</td>
          <td> 0.93</td>
          <td> 13801.665</td>
          <td> 3505</td>
          <td> 45700.513</td>
          <td> 490.52</td>
        </tr>
        <tr>
          <th>2014-12-29 00:02:00-08:00</th>
          <td> 43566.850</td>
          <td> 27.74</td>
          <td> 0.94</td>
          <td> 13801.740</td>
          <td> 3505</td>
          <td> 45700.749</td>
          <td> 490.00</td>
        </tr>
        <tr>
          <th>2014-12-29 00:03:00-08:00</th>
          <td> 43567.077</td>
          <td> 30.02</td>
          <td> 0.93</td>
          <td> 13801.816</td>
          <td> 3505</td>
          <td> 45700.989</td>
          <td> 489.29</td>
        </tr>
        <tr>
          <th>2014-12-29 00:04:00-08:00</th>
          <td> 43567.310</td>
          <td> 28.41</td>
          <td> 0.93</td>
          <td> 13801.901</td>
          <td> 3505</td>
          <td> 45701.236</td>
          <td> 491.54</td>
        </tr>
        <tr>
          <th>2014-12-29 00:05:00-08:00</th>
          <td> 43567.541</td>
          <td> 27.81</td>
          <td> 0.94</td>
          <td> 13801.986</td>
          <td> 3505</td>
          <td> 45701.482</td>
          <td> 491.18</td>
        </tr>
      </tbody>
    </table>
    </div>



``search_group_tree`` accepts a keyword and searches the instantiated client for matching sensor groups returning group names, sensor group ID, and assigned sensors.

.. code:: python

    stream.search_group_tree('Engineering',case=False).head()



.. raw:: html

    <div style="max-height:1000px;max-width:1500px;overflow:auto;">
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>name</th>
          <th>description</th>
          <th>load_type</th>
          <th>sensorGroups</th>
          <th>sensors</th>
          <th>groupMultiplier</th>
          <th>time_zone</th>
          <th>weatherStationId</th>
          <th>base_group_level</th>
        </tr>
        <tr>
          <th>sensorGroupId</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>2177</th>
          <td>       Rockwell Engineering Center - Sub Groups</td>
          <td>       Rockwell Engineering Center - Sub Groups</td>
          <td> building</td>
          <td>     Int64Index([2179, 2178, 2180], dtype='int64')</td>
          <td>                                              None</td>
          <td>                   [1, 1, 1]</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 1</td>
        </tr>
        <tr>
          <th>2258</th>
          <td> Engineering and Computing Trailer - Sub Groups</td>
          <td> Engineering and Computing Trailer - Sub Groups</td>
          <td> building</td>
          <td>                                              None</td>
          <td> [{u'timeZoneId': 67, u'sourceTypeId': 1, u'des...</td>
          <td>                        None</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 1</td>
        </tr>
        <tr>
          <th>157 </th>
          <td>   Engineering Laboratory Facility - Sub Groups</td>
          <td>                          Feed to ELF Sub Loads</td>
          <td> building</td>
          <td> Int64Index([196, 193, 192, 195, 194], dtype='i...</td>
          <td>                                              None</td>
          <td>             [1, 1, 1, 1, 1]</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 1</td>
        </tr>
        <tr>
          <th>255 </th>
          <td>                 Engineering Tower - Sub Groups</td>
          <td>                          Feed to ET Sub Groups</td>
          <td> building</td>
          <td> Int64Index([258, 256, 257, 262, 263, 260, 261,...</td>
          <td>                                              None</td>
          <td> [1, 1, 1, 1, 1, 1, 1, 1, 1]</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 1</td>
        </tr>
        <tr>
          <th>265 </th>
          <td>          Engineering Lecture Hall - Sub Groups</td>
          <td>                           Feed ELH Sub Groups </td>
          <td> building</td>
          <td> Int64Index([274, 266, 271, 267, 270, 273, 272]...</td>
          <td>                                              None</td>
          <td>       [1, 1, 1, 3, 3, 3, 3]</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 1</td>
        </tr>
      </tbody>
    </table>
    </div>



Sensors are grouped in a heirarchy by level.

.. code:: python

    stream.groups[stream.groups.base_group_level == 0].head()



.. raw:: html

    <div style="max-height:1000px;max-width:1500px;overflow:auto;">
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>name</th>
          <th>description</th>
          <th>load_type</th>
          <th>sensorGroups</th>
          <th>sensors</th>
          <th>groupMultiplier</th>
          <th>time_zone</th>
          <th>weatherStationId</th>
          <th>base_group_level</th>
        </tr>
        <tr>
          <th>sensorGroupId</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>216 </th>
          <td>        UCI - MelRok Electric Meter Sub Groups</td>
          <td>         Feed to Individual Loads at UCI Buildings</td>
          <td> campus</td>
          <td> Int64Index([2203, 2193, 2198, 2188, 2177, 2181...</td>
          <td> None</td>
          <td> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 0</td>
        </tr>
        <tr>
          <th>734 </th>
          <td>             UCI - Electric Distribution Loads</td>
          <td> Electrical Meters that Distribute Electricity ...</td>
          <td> campus</td>
          <td> Int64Index([732, 733, 1836, 1837, 1838, 1839, ...</td>
          <td> None</td>
          <td>                      [1, 1, 1, 1, 1, 1, -1, 1, 1]</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 0</td>
        </tr>
        <tr>
          <th>769 </th>
          <td> UCI - Building Heating &amp; Chilled Water Meters</td>
          <td>                      14 KEP-ES749 for 6 Buildings</td>
          <td> campus</td>
          <td> Int64Index([774, 775, 772, 771, 776, 777, 1824...</td>
          <td> None</td>
          <td>                       [1, 1, 1, 1, 1, 1, 1, 1, 1]</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 0</td>
        </tr>
        <tr>
          <th>1843</th>
          <td>                     UCI - Total Electric Load</td>
          <td>                Total Electric Load for UCI Campus</td>
          <td> campus</td>
          <td> Int64Index([735, 1842, 1484, 1483, 1486, 1485,...</td>
          <td> None</td>
          <td> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...</td>
          <td> America/Los_Angeles</td>
          <td> 102</td>
          <td> 0</td>
        </tr>
      </tbody>
    </table>
    </div>



``sensors`` returns a dataframe describing the individual sensors associated with the instantiated energistream client ID. This includes the sensor ID, the associated group ID, time zone, and a multiplier based on the method of measurement i.e. one, two, or three channel.

.. code:: python

    stream.sensors.head()



.. raw:: html

    <div style="max-height:1000px;max-width:1500px;overflow:auto;">
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>description</th>
          <th>iconId</th>
          <th>multiplier</th>
          <th>name</th>
          <th>properties</th>
          <th>sensorFunctionTypeId</th>
          <th>sensorGroupId</th>
          <th>sourceTypeId</th>
          <th>time_zone</th>
        </tr>
        <tr>
          <th>sensorId</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>8812</th>
          <td> D40010000628-04</td>
          <td> 21</td>
          <td> 1</td>
          <td> ECT B1</td>
          <td> [{u'name': u'Phase', u'value': u'A'}]</td>
          <td> 1</td>
          <td> 2258</td>
          <td> 1</td>
          <td> America/Los_Angeles</td>
        </tr>
        <tr>
          <th>8813</th>
          <td> D40010000628-05</td>
          <td> 21</td>
          <td> 1</td>
          <td> ECT B2</td>
          <td> [{u'name': u'Phase', u'value': u'C'}]</td>
          <td> 1</td>
          <td> 2258</td>
          <td> 1</td>
          <td> America/Los_Angeles</td>
        </tr>
        <tr>
          <th>8814</th>
          <td> D40010000628-06</td>
          <td> 21</td>
          <td> 1</td>
          <td> ECT B3</td>
          <td> [{u'name': u'Phase', u'value': u'B'}]</td>
          <td> 1</td>
          <td> 2258</td>
          <td> 1</td>
          <td> America/Los_Angeles</td>
        </tr>
        <tr>
          <th>8815</th>
          <td> D40010000628-07</td>
          <td> 21</td>
          <td> 1</td>
          <td> ECT B4</td>
          <td> [{u'name': u'Phase', u'value': u'A'}]</td>
          <td> 1</td>
          <td> 2258</td>
          <td> 1</td>
          <td> America/Los_Angeles</td>
        </tr>
        <tr>
          <th>8816</th>
          <td> D40010000628-08</td>
          <td> 21</td>
          <td> 1</td>
          <td> ECT B5</td>
          <td> [{u'name': u'Phase', u'value': u'C'}]</td>
          <td> 1</td>
          <td> 2258</td>
          <td> 1</td>
          <td> America/Los_Angeles</td>
        </tr>
      </tbody>
    </table>
    </div>



``get_boards`` returns a dataframe describing the boards associated with the instantiated energistream client ID. This includes 
the boards serial number, version, display name, and model.

.. code:: python

    stream.get_boards.head()



.. raw:: html

    <div style="max-height:1000px;max-width:1500px;overflow:auto;">
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>currentConfigVersion</th>
          <th>displayName</th>
          <th>firmwareVersion</th>
          <th>manufacturer</th>
          <th>model</th>
          <th>sensors</th>
          <th>timeZoneId</th>
        </tr>
        <tr>
          <th>serialNumber</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>C20006000002</th>
          <td> 26</td>
          <td> MSTB First Floor 2</td>
          <td> 1</td>
          <td> MelRok Manufacturer</td>
          <td> EN-12</td>
          <td> [{u'timeZoneId': 67, u'sourceTypeId': 1, u'nam...</td>
          <td> 67</td>
        </tr>
        <tr>
          <th>C20006000003</th>
          <td> 21</td>
          <td> MSTB First Floor 3</td>
          <td> 1</td>
          <td> MelRok Manufacturer</td>
          <td> EN-12</td>
          <td> [{u'timeZoneId': 67, u'sourceTypeId': 1, u'nam...</td>
          <td> 67</td>
        </tr>
        <tr>
          <th>C20006000004</th>
          <td> 25</td>
          <td>  MSTB Second Floor</td>
          <td> 1</td>
          <td> MelRok Manufacturer</td>
          <td> EN-12</td>
          <td> [{u'timeZoneId': 67, u'sourceTypeId': 1, u'nam...</td>
          <td> 67</td>
        </tr>
        <tr>
          <th>A30006000036</th>
          <td> 20</td>
          <td>       Aldrich Hall</td>
          <td> 1</td>
          <td> MelRok Manufacturer</td>
          <td> EN-12</td>
          <td> [{u'timeZoneId': 67, u'sourceTypeId': 1, u'nam...</td>
          <td> 67</td>
        </tr>
        <tr>
          <th>A30006000041</th>
          <td> 18</td>
          <td> Social Science LAB</td>
          <td> 1</td>
          <td> MelRok Manufacturer</td>
          <td> EN-12</td>
          <td> [{u'timeZoneId': 67, u'sourceTypeId': 1, u'nam...</td>
          <td> 67</td>
        </tr>
      </tbody>
    </table>
    </div>



``get_demand`` returns the fifteen minute demand rate for the given sensor group. Start and end date may be specified as well as the timezone and desired resolution. Note : Defaults to the last thirty days and fifteen minute resolution.

.. code:: python

    stream.get_demand(157).head()



.. parsed-literal::

    2015-02-05 13:44:59-08:00     43.339200
    2015-02-05 13:59:59-08:00     44.102333
    2015-02-05 14:14:59-08:00     79.040466
    2015-02-05 14:29:59-08:00    131.523733
    2015-02-05 14:44:59-08:00     45.773866
    Name: kW, dtype: float64



Presentation and Analysis Examples
**********************************
seaborn is used to plot aesthetically pleasing charts and graphs. The following commands set up the presentation by defining the seaborn aesthetics, chart sizing, and figure scaling to be used. 
.. code:: python

    sns.set(font='Bitstream Vera Sans')
    sns.set_context('poster')
    #sns.set_context("poster", font_scale=1.7)
    sns.plotting_context()



.. parsed-literal::

    {'axes.labelsize': 17.6,
     'axes.titlesize': 19.200000000000003,
     'figure.figsize': array([ 12.8,   8.8]),
     'grid.linewidth': 1.6,
     'legend.fontsize': 16.0,
     'lines.linewidth': 2.8000000000000003,
     'lines.markeredgewidth': 0.0,
     'lines.markersize': 11.200000000000001,
     'patch.linewidth': 0.48,
     'xtick.labelsize': 16.0,
     'xtick.major.pad': 11.200000000000001,
     'xtick.major.width': 1.6,
     'xtick.minor.width': 0.8,
     'ytick.labelsize': 16.0,
     'ytick.major.pad': 11.200000000000001,
     'ytick.major.width': 1.6,
     'ytick.minor.width': 0.8}



A large dataset at a sufficiently fine resolution may contain very large short duration demand spikes which are not indicative of the actual demand. These spikes may be filtered out, carefully, by masking demand values that exceed a defined limit.
.. code:: python

    
    demand = stream.get_demand(216)
    multi = 1.5
    mask = (demand < 0) | (demand > demand.mean() + multi * demand.std())

Seen below is the demand charted over a thirty day time period. This can provide insight into demand over time such as due to changes in the weather or building usage. Note the regularly spaced peaks during the work-day and comparatively smaller spikes which occur on off-days. There is a three day period of reduced demand coinciding with February 16th, a Federal Holiday.  
.. code:: python

    demand.mask(mask).plot()
    
    plt.title('30 Day Demand for UCI - Melrok Loads')
    plt.ylabel('Demand [kW]')



.. parsed-literal::

    <matplotlib.text.Text at 0x11659c790>




.. image:: stream_examples_files/stream_examples_30_1.png


Taking the mean and median of the days creates a single chart representing an average demand day. This is useful for examining a typical demand profile such as to obverve the time of peak loads and the duration of regular demand spikes. In this case the peak occurs in the middle of the afternoon around 3 PM. Comparing the mean and median offers quick insight into the daily variation in demand.
.. code:: python

    mean = demand.mask(mask).groupby([demand.index.hour,demand.index.minute]).mean().plot(color = 'b', label = 'mean')
    median = demand.mask(mask).groupby([demand.index.hour,demand.index.minute]).median().plot(color = 'g', label = 'median')
    legend()
    
    plt.title('Demand Profile for UCI - Melrok Loads')
    plt.ylabel('Demand [kW]')
    
    plt.xticks( (16 * arange(7)),['12AM','4AM','8AM','12PM','4PM','8PM','12AM'])



.. parsed-literal::

    ([<matplotlib.axis.XTick at 0x11659c050>,
      <matplotlib.axis.XTick at 0x112f7b810>,
      <matplotlib.axis.XTick at 0x1168cf290>,
      <matplotlib.axis.XTick at 0x1168cfa50>,
      <matplotlib.axis.XTick at 0x1168c7210>,
      <matplotlib.axis.XTick at 0x1168c7990>,
      <matplotlib.axis.XTick at 0x1168b9090>],
     <a list of 7 Text xticklabel objects>)




.. image:: stream_examples_files/stream_examples_32_1.png


A histogram is another useful way to examine the distribution of the demand, plotting demand magnitude by the total number of events in the data set.
.. code:: python

    demand.mask(mask).hist(bins=80)
    
    plt.title('Demand Histogram - Melrok Loads')
    plt.ylabel('Number of Events')
    plt.xlabel('Demand [kW]')



.. parsed-literal::

    <matplotlib.text.Text at 0x1168ee210>




.. image:: stream_examples_files/stream_examples_34_1.png


